<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DelightMate - Your AI Assistant</title>
    <link href="{{ url_for('static', filename='css/tailwind.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/cosmic.css') }}" rel="stylesheet">
    <script src="{{ url_for('static', filename='js/theme.js') }}"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
    </style>
</head>
<body style="background-color: var(--bg-color);">
    <div class="cosmos-container">
        {% include 'components/navbar.html' %}
        
        <!-- User Profile -->
        {% if user and user.is_logged_in %}
        <div class="cosmic-user-profile">
            {% if user.picture %}
            <img src="{{ user.picture }}" alt="Profile">
            {% else %}
            <div style="width: 40px; height: 40px; border-radius: 50%; background-color: rgba(64, 190, 255, 0.8); display: flex; justify-content: center; align-items: center; color: white; font-weight: bold;">
                {{ user.name[0] if user.name else 'U' }}
            </div>
            {% endif %}
            <span class="cosmic-user-name">{{ user.name if user.name else 'User' }}</span>
        </div>
        {% endif %}
        
        <!-- Voice Mode Indicator -->
        <!-- <div class="voice-mode">Voice mode</div> -->
        
        <!-- Welcome Message -->
        <!-- <div class="cosmic-welcome" id="welcomeMessage">
            <h2>I'm DelightMate</h2>
            <p>Your digital teammate ready to help with emails, calendar, and more.</p>
            <p class="welcome-hint">Click the microphone to start speaking</p>
        </div> -->

        <!-- Cosmic Sphere -->
        <div class="cosmos-sphere" id="cosmosSphere"></div>
        
        <!-- Status Text -->
        <div class="status-text" id="statusText">Listening...</div>
        
        <!-- Response Container -->
        <div class="cosmic-message-container" id="messageContainer">
            <p class="cosmic-message" id="responseMessage"></p>
        </div>
        
        <!-- Control Buttons -->
        <div class="controls">
            <button class="control-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
                </svg>
            </button>
            <button class="control-btn microphone-btn" id="micButton">
                <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                    <line x1="12" y1="19" x2="12" y2="23"></line>
                    <line x1="8" y1="23" x2="16" y2="23"></line>
                </svg>
            </button>
            <button class="control-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
            </button>
        </div>

    </div>

    <!-- JavaScript for Cosmic Visualization and Audio Recording -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const cosmosSphere = document.getElementById('cosmosSphere');
            const statusText = document.getElementById('statusText');
            const micButton = document.getElementById('micButton');
            const messageContainer = document.getElementById('messageContainer');
            const responseMessage = document.getElementById('responseMessage');
            let isListening = false;
            let mediaRecorder = null;
            let audioChunks = [];
            let isProcessing = false;
            
            // Create cosmic particles
            createCosmicParticles();
            
            // Microphone button click handler
            micButton.addEventListener('click', function() {
                if (isProcessing) return; // Prevent multiple clicks during processing
                
                if (isListening) {
                    stopRecording();
                } else {
                    startRecording();
                }
            });
            
            // Initialize audio recording capabilities
            async function startRecording() {
                try {
                    // Request microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    // Start animation
                    startListening();
                    
                    // Hide welcome message
                    const welcomeMessage = document.getElementById('welcomeMessage');
                    if (welcomeMessage) {
                        welcomeMessage.style.opacity = '0';
                        welcomeMessage.style.transform = 'translateY(-50px)';
                    }
                    
                    // Setup audio context for visualization
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const analyser = audioContext.createAnalyser();
                    const microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);
                    analyser.fftSize = 256;
                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);
                    
                    // Setup media recorder
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    
                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };
                    
                    mediaRecorder.onstop = processAudio;
                    
                    // Start recording
                    mediaRecorder.start();
                    
                    // Setup visualization animation
                    function animate() {
                        if (!isListening) return;
                        
                        analyser.getByteFrequencyData(dataArray);
                        // Calculate average volume
                        let sum = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            sum += dataArray[i];
                        }
                        const average = sum / bufferLength;
                        
                        // Scale particles based on volume
                        const particles = document.querySelectorAll('.particle');
                        const scale = 1 + (average / 256) * 0.5; // Scale between 1 and 1.5
                        
                        // Make cosmos sphere pulsate based on audio level
                        const pulseScale = 1 + (average / 256) * 0.1; // Subtle pulse effect
                        cosmosSphere.style.transform = `scale(${pulseScale})`;
                        
                        particles.forEach(particle => {
                            particle.style.transform = `scale(${scale})`;
                        });
                        
                        requestAnimationFrame(animate);
                    }
                    
                    animate();
                    
                } catch (err) {
                    console.error('Error accessing microphone:', err);
                    alert('Error accessing microphone. Please ensure your microphone is connected and permissions are granted.');
                }
            }
            
            function stopRecording() {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    isProcessing = true;
                    statusText.textContent = 'Processing...';
                    mediaRecorder.stop();
                    stopListening();
                }
            }
            
            async function processAudio() {
                try {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const formData = new FormData();
                    formData.append('audio', audioBlob);
                    
                    statusText.textContent = 'Processing...';
                    statusText.classList.add('active');
                    
                    // Send to backend for processing
                    const response = await fetch('/api/stt', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // Process the transcript
                        const transcript = data.transcript;
                        console.log('Transcript:', transcript);
                        
                        // Show user message
                        const userBubble = document.createElement('div');
                        userBubble.className = 'user-bubble';
                        userBubble.textContent = transcript;
                        messageContainer.appendChild(userBubble);
                        messageContainer.style.display = 'block';
                        
                        statusText.textContent = 'Thinking...';
                        
                        // Now get AI response for the transcript
                        const aiResponse = await fetch('/api/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ message: transcript })
                        });
                        
                        const aiData = await aiResponse.json();
                        
                        if (aiData.success) {
                            // Display AI response
                            simulateResponse(aiData.response);
                            
                            // Convert to speech
                            speakResponse(aiData.response);
                        } else {
                            simulateResponse("I'm sorry, I couldn't process your request. Please try again.");
                        }
                    } else {
                        simulateResponse("I couldn't hear you clearly. Could you please try again?");
                    }
                } catch (err) {
                    console.error('Error processing audio:', err);
                    simulateResponse("There was an error processing your audio. Please try again.");
                } finally {
                    isProcessing = false;
                    statusText.classList.remove('active');
                }
            }
            
            async function speakResponse(text) {
                try {
                    const response = await fetch('/api/tts', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ text })
                    });
                    
                    if (response.ok) {
                        const blob = await response.blob();
                        const url = URL.createObjectURL(blob);
                        const audio = new Audio(url);
                        audio.play();
                    }
                } catch (err) {
                    console.error('Error with text-to-speech:', err);
                }
            }
            
            // Create cosmic particles in the sphere
            function createCosmicParticles() {
                const colors = ['white', 'blue', 'cyan', 'purple', 'pink'];
                const totalParticles = 200;
                const sphereRadius = 180; // Radius of the cosmic sphere
                
                cosmosSphere.innerHTML = ''; // Clear existing particles
                
                for (let i = 0; i < totalParticles; i++) {
                    const particle = document.createElement('div');
                    particle.className = `particle ${colors[Math.floor(Math.random() * colors.length)]}`;
                    
                    // Random size between 2-6px
                    const size = Math.random() * 4 + 2;
                    particle.style.width = `${size}px`;
                    particle.style.height = `${size}px`;
                    
                    // Position randomly within the sphere (spherical coordinates)
                    const theta = Math.random() * Math.PI * 2; // Horizontal angle
                    const phi = Math.acos(2 * Math.random() - 1); // Vertical angle
                    const radius = Math.random() * sphereRadius; // Distance from center
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    // Calculate opacity based on distance from center (more transparency at edges)
                    const opacity = 0.1 + (1 - (radius / sphereRadius)) * 0.9;
                    
                    // Set animation delay as a CSS variable
                    const delay = Math.random() * 2;
                    particle.style.setProperty('--particle-delay', delay);
                    
                    // Apply styles
                    particle.style.left = `calc(50% + ${x}px)`;
                    particle.style.top = `calc(50% + ${y}px)`;
                    particle.style.opacity = opacity;
                    particle.style.transform = `translateZ(${z}px)`;
                    
                    // Add subtle movement animation
                    const animDuration = 20 + Math.random() * 80;
                    const animDelay = Math.random() * -animDuration;
                    
                    // Use multiple animations for more interesting movement
                    particle.style.animation = `
                        rotate ${animDuration}s linear ${animDelay}s infinite,
                        float ${10 + Math.random() * 10}s ease-in-out ${Math.random() * -10}s infinite
                    `;
                    
                    cosmosSphere.appendChild(particle);
                }
            }
            
            // Start listening animation
            function startListening() {
                isListening = true;
                document.body.classList.add('listening');
                statusText.classList.add('active');
                statusText.textContent = 'Listening...';
                cosmosSphere.classList.add('pulsate');
                messageContainer.style.display = 'none';
                
                // Make particles bulge with microphone input (real-time audio will handle this)
                const particles = document.querySelectorAll('.particle');
                particles.forEach(particle => {
                    // Add random delay for each particle to create a wave effect
                    const randomDelay = Math.random() * 0.5;
                    particle.style.setProperty('--particle-delay', randomDelay);
                });
            }
            
            // Stop listening animation
            function stopListening() {
                isListening = false;
                document.body.classList.remove('listening');
                statusText.classList.remove('active');
                cosmosSphere.classList.remove('pulsate');
                cosmosSphere.style.transform = '';
                
                // Show welcome message after response is displayed
                setTimeout(() => {
                    const welcomeMessage = document.getElementById('welcomeMessage');
                    if (welcomeMessage && !messageContainer.style.display || messageContainer.style.display === 'none') {
                        welcomeMessage.style.opacity = '0.95';
                        welcomeMessage.style.transform = 'translateY(-100px)';
                    }
                }, 1000);
                
                // Reset particles
                const particles = document.querySelectorAll('.particle');
                particles.forEach(particle => {
                    particle.style.transform = '';
                });
            }
            
            // Display AI response with animation
            function simulateResponse(text) {
                // Display the message container
                messageContainer.style.display = 'block';
                
                // Create a new message bubble
                const aiBubble = document.createElement('div');
                aiBubble.className = 'ai-bubble';
                messageContainer.appendChild(aiBubble);
                
                // Animate text appearing word by word
                const words = text.split(' ');
                responseMessage.textContent = ''; // Clear existing text for the SR reader
                
                let wordIndex = 0;
                const wordInterval = setInterval(() => {
                    if (wordIndex < words.length) {
                        aiBubble.textContent += (wordIndex === 0 ? '' : ' ') + words[wordIndex];
                        responseMessage.textContent = aiBubble.textContent; // For screen readers
                        wordIndex++;
                    } else {
                        clearInterval(wordInterval);
                    }
                }, 50); // Speed of text appearance - a bit faster than before
                
                // Scroll to the bottom of the container
                messageContainer.scrollTop = messageContainer.scrollHeight;
            }
        });
    </script>

    <!-- Footer -->
    <footer class="py-4 text-center text-blue-800 mt-auto">
        <p class="text-sm">&copy; 2025 DelightMate - Your Intelligent Assistant</p>
    </footer>

</body>
</html>